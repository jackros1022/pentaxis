/*
 * YoubotArmAnalyticalIK.h
 *
 *  Created on: Oct 29, 2013
 *      Author: raha
 */

#ifndef YOUBOTARMANALYTICALIK_H_
#define YOUBOTARMANALYTICALIK_H_

#include "YoubotArmIK.h"

namespace youbot_kinematics
{
/**
 * An analytical IK solver for the youBot arm.
 */
class YoubotArmAnalyticalIK: public YoubotArmIK
{
public:
  /**
   * Ctor.
   *
   * @brief Initialize the solver by providing a urdf::Model and a root and tip name.
   * @param robot_model A urdf::Model representation of the youBot robot model
   * @param robot_description The XML string that of a urdf::Model which represents the youBot robot model
   * @param root_name The root joint name of the arm
   * @param joint_name The tip joint name of the arm
   */
  YoubotArmAnalyticalIK(const urdf::ModelInterface &robot_model,
    const std::string &robot_description,
    const std::string &root_name,
    const std::string &tip_name);

  /**
   * Dtor.
   */
  virtual ~YoubotArmAnalyticalIK();

  /**
   * @see InverseKinematics::CartToJnt
   */
  int CartToJnt(const KDL::JntArray& q_init,
    const KDL::Frame& p_in,
    std::vector<KDL::JntArray>& q_out);

  /**
   * @see InverseKinematics::getSolverInfo
   */
  void getSolverInfo(moveit_msgs::KinematicSolverInfo &response);


private:

	void solveJoint1(double joint5, bool j5_set);
	void solveJoint5(double joint1, bool j1_set);
	void solveJoint3(double joint1, double joint5);
	void solveJoint2(double joint1, double joint5, double joint3, std::vector<double> &_Gamma, std::vector<double> &_Omega);
	void solveJoint4(double joint1, double joint5, double joint3, double joint2);
	
	void addNewSolution(double j1, double j2, double j3, double j4, double j5);

	bool validateJoint(int j_index, double j_element, std::vector<double> &j_vector);
	
	/**
	* Tell if the IK corresponse to the given FK
	*
	*	@param joint1-5. The set of joints to be tested.
	* @return True if it's a valid solution value else false.
	*/
	bool validateSolutionWithFK(double joint1, double joint5, double joint3, double joint2, double joint4);

	/**
	* Adds a new element to a vector if its unique.
	*
	*	@param vect. The set of elements.
	*	@param newElement. The element to be tested.
	* @return True if a new element has been added in the vector.
	*/
	bool push_back_ifUnique(std::vector<double> &vect, double newElement);

	/**
	* Tell if a single Joint value is inside of the joint limits.
	*
	*	@param jointValue The joint value to be tested.
	* @return True if it's a valid joint value else false.
	*/
	bool isJointValid(double jointValue, int jointNum) const;

  /**
   * Tell if a solution is inside of the joint limits.
   *
   * @param solution The solution that has been generated by the IK
   *          solver.
   * @return True if the solution is valid else false.
   */
  bool isSolutionValid(const KDL::JntArray &solution) const;

  
  void ik(const KDL::Frame& frame);

  //KDL::Frame ProjectGoalOrientationIntoArmSubspace(const KDL::Frame &goal) const;


private:
  /**
   * Minimum joint limits.
   */
  std::vector<double> _min_angles;

  /**
   * Maximum joint limits.
   */
  std::vector<double> _max_angles;

  /**
   * Information about the IK solver.
   */
  moveit_msgs::KinematicSolverInfo _solver_info;
  
  /**
   * The FK given to solve it's IK.
   */
  double nx, ox, ax, px;
	double ny, oy, ay, py;
	double nz, oz, az, pz;
	
	/*
	* Solutions found
	*/	
	std::vector<KDL::JntArray> solutions;
	
	/*
	* Denavit-Hartenberg Parameters for the Pentaxis robot.
	*/
	double d0;
	double d1;
	double d5;
	double d6; // 12.1
	double a2;
	double a3;
	
  /**
   * Threshold when a number is near to +1 or -1. This is required to
   * prevent invalid arguments to acos.
   */
  static const double ALMOST_PLUS_ONE;
  static const double ALMOST_MINUS_ONE;
};

} /* namespace youbot_kinematics */

#endif /* YOUBOTARMANALYTICALIK_H_ */
