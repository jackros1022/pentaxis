/*
 * YoubotArmAnalyticalIK.cpp
 *
 *  Created on: Oct 29, 2013
 *      Author: raha
 */

#include "YoubotArmAnalyticalIK.h"

// ROS includes
//#include <pr2_arm_kinematics/pr2_arm_kinematics_utils.h>
#include <kdl/chainfksolverpos_recursive.hpp>
#include <kdl/chainiksolvervel_pinv.hpp>
#include <kdl/chainiksolverpos_nr_jl.hpp>
#include <ros/console.h>
// Package includes
#include "../SolverInfoProcessor.h"

// C++ includes
//#include <iostream> //for cout

namespace youbot_kinematics
{

#define DEG_TO_RAD(x) ((x) * M_PI / 180.0)

const double YoubotArmAnalyticalIK::ALMOST_PLUS_ONE = 0.9999999;
const double YoubotArmAnalyticalIK::ALMOST_MINUS_ONE = -0.9999999;


YoubotArmAnalyticalIK::YoubotArmAnalyticalIK(
    const urdf::ModelInterface &robot_model,
    const std::string &robot_description,
    const std::string &root_name,
    const std::string &tip_name)
{
	ROS_INFO("IK SOLVER STARTED");
	/*
	* Denavit-Hartenberg Parameters for the Pentaxis robot.
	*/
	d0 = 0.152;
	d1 = 0.259;
	d5 = 0.035;
	d6 = 0.0; // 12.1
	a2 = 0.252; // OG: 0.252
	a3 = 0.250; // TODO this should somewhere else
  SolverInfoProcessor solver_info_processor(robot_model, tip_name, root_name);
  _solver_info = solver_info_processor.getSolverInfo();
  
  for (unsigned int i = 0; i < _solver_info.joint_names.size(); i++)
  {
    _min_angles.push_back(_solver_info.limits[i].min_position);
    _max_angles.push_back(_solver_info.limits[i].max_position);
  }
}

YoubotArmAnalyticalIK::~YoubotArmAnalyticalIK()
{
  // TODO Auto-generated destructor stub
}

int YoubotArmAnalyticalIK::CartToJnt(const KDL::JntArray& q_init,
    const KDL::Frame& p_in,
    std::vector<KDL::JntArray>& q_out)
{

  // there are no solutions available yet
  q_out.clear();
	solutions.clear();
	ik(p_in);
  if(solutions.size() > 0) {
  	for(unsigned int i = 0; i < solutions.size(); i++) {
  		if(validateSolutionWithFK(solutions[i](0), solutions[i](1), solutions[i](2), solutions[i](3), solutions[i](4)))
  			q_out.push_back(solutions[i]);
  	}
  	if(q_out.size() > 0) {
    	ROS_INFO_STREAM("Inverse Kinematic found " <<  q_out.size() << " solutions.");
    	return 1;
    } else {
    	ROS_INFO_STREAM("Inverse Kinematics found a solution for:\n" <<nx<<"\t"<<ox<<"\t"<<ax<<"\t"<<px<<"\n"<<
	ny<<"\t"<< oy<<"\t"<< ay<<"\t"<< py<<"\n"<<
	nz<<"\t"<< oz<<"\t"<< az<<"\t"<< pz<< "\n But does not correspond to the forward kinematics.");
    }
  } else {
    ROS_WARN("Inverse Kinematic found no solution.");
    return -1;
  }
}


void YoubotArmAnalyticalIK::getSolverInfo(
    moveit_msgs::KinematicSolverInfo &info) {
	info = _solver_info;
}


void YoubotArmAnalyticalIK::ik(const KDL::Frame& g0) {
	nx = g0(0,0); ox = g0(0,1); ax = g0(0,2); px = g0(0,3);
	ny = g0(1,0); oy = g0(1,1); ay = g0(1,2); py = g0(1,3);
	nz = g0(2,0); oz = g0(2,1); az = g0(2,2); pz = g0(2,3);

	solveJoint1(0.0, false);
	solveJoint5(0.0, false);
}

/*
* JOINT 1
*/
void YoubotArmAnalyticalIK::solveJoint1(double joint5, bool j5_set) {
	std::vector<double> j1;
	double tempSolution = atan2(py,px); // 1st solution
	if(validateJoint(0, tempSolution, j1)) {
		if(j5_set) solveJoint3(j1.back(), joint5);
		else solveJoint5(j1.back(), true);
	}
  
	tempSolution = atan2(ay,ax); // 2nd solution
	if(validateJoint(0, tempSolution, j1)) {
		if(j5_set) solveJoint3(j1.back(), joint5);
		else solveJoint5(j1.back(), true);
	}
		
	tempSolution = atan2(-(ox+az*ny),oy-az*nx); // 3rd solution
	if(validateJoint(0, tempSolution, j1)) {
		if(j5_set) solveJoint3(j1.back(), joint5);
		else solveJoint5(j1.back(), true);
	}
	tempSolution = atan2((ox+az*ny),-(oy-az*nx)); // 3rd solution
	if(validateJoint(0, tempSolution, j1)) {
		if(j5_set) solveJoint3(j1.back(), joint5);
		else solveJoint5(j1.back(), true);
	}
		
	tempSolution = atan2(nx-az*oy, -ny-az*ox); // 4th solution
	if(validateJoint(0, tempSolution, j1)) {
		if(j5_set) solveJoint3(j1.back(), joint5);
		else solveJoint5(j1.back(), true);
	}
	tempSolution = atan2(-(nx-az*oy), ny+az*ox); // 4th solution
	if(validateJoint(0, tempSolution, j1)) {
		if(j5_set) solveJoint3(j1.back(), joint5);
		else solveJoint5(j1.back(), true);
	}
	
	if(j5_set) {
		double s5 = sin(joint5);
		double c5 = cos(joint5);
		double j1_cos = (s5*ny+c5*oy)/2.0;
		double j1_sin = (-s5*nx-c5*ox)/2.0;
		tempSolution = atan2(j1_sin, j1_cos); // 5th solution
		if(validateJoint(0, tempSolution, j1))
			solveJoint3(j1.back(), joint5);
	}

	if(j1.size() < 1 && !j5_set) { // when the arm is in the upright position
		ROS_DEBUG("Assuming joint5 = 0");
		tempSolution = atan2(ox,oy);  // 6th solution
		if(validateJoint(0, tempSolution, j1))
			solveJoint3(j1.back(), 0.0);
	}
	
	if(j1.size() == 0)
		ROS_DEBUG("Unable to find solution for joint 1");
}


/*
* JOINT 5
*/
void YoubotArmAnalyticalIK::solveJoint5(double joint1, bool j1_set) {
	std::vector<double> j5;
	double tempSolution;
	
	if(j1_set) {
		double c1 = cos(joint1);
		double s1 = sin(joint1);
		double j5_sin = (c1*ny-s1*nx)/2.0;
		double j5_cos = (c1*oy-s1*ox)/2.0;
		tempSolution = atan2(j5_sin, j5_cos); // 1st solution
		if(validateJoint(4, tempSolution, j5))
			solveJoint3(joint1, j5.back());
	}
		
	tempSolution = atan2(oz,-nz); // 2nd solution
	if(validateJoint(4, tempSolution, j5)) {
		if(j1_set) solveJoint3(joint1, j5.back());
		else solveJoint1(j5.back(), true);
	}
	tempSolution = atan2(-oz,nz); // 2nd solution
	if(validateJoint(4, tempSolution, j5)) {
		if(j1_set) solveJoint3(joint1, j5.back());
		else solveJoint1(j5.back(), true);
	}
		
	tempSolution = atan2(oy*az-nx,-ox-az*ny); // 3rd solution
	if(validateJoint(4, tempSolution, j5)) {
		if(j1_set) solveJoint3(joint1, j5.back());
		else solveJoint1(j5.back(), true);
	}
	tempSolution = atan2(-(oy*az-nx), ox+az*ny); // 3rd solution
	if(validateJoint(4, tempSolution, j5)) {
		if(j1_set) solveJoint3(joint1, j5.back());
		else solveJoint1(j5.back(), true);
	}
		
	tempSolution = atan2(-ny-az*ox, oy+az*nx); // 4th solution
	if(validateJoint(4, tempSolution, j5)) {
		if(j1_set) solveJoint3(joint1, j5.back());
		else solveJoint1(j5.back(), true);
	}
	tempSolution = atan2(ny+az*ox, -(oy+az*nx)); // 4th solution
	if(validateJoint(4, tempSolution, j5)) {
		if(j1_set) solveJoint3(joint1, j5.back());
		else solveJoint1(j5.back(), true);
	}

	if(j5.size() == 0)
		ROS_DEBUG("Unable to find solution for joint 5");
}

/*
* JOINT 3
*/
void YoubotArmAnalyticalIK::solveJoint3(double joint1, double joint5) {
	double c1 = cos(joint1);
	double s1 = sin(joint1);
	double c5 = cos(joint5);
	double s5 = sin(joint5);
	std::vector<double> _Gamma;
	std::vector<double> _Omega;
	std::vector<double> j3;
	
	if(c1 != 0.0) {
		push_back_ifUnique(_Gamma, px/c1 - (d5+d6)*(ax/c1));
		if(c5 != 0.0) 
			push_back_ifUnique(_Gamma, px/c1 + (d5+d6)*(nz/c5));
		if(s1 != 0.0) 
			push_back_ifUnique(_Gamma, px/c1 - (d5+d6)*(ay/s1));
		if(s5 != 0.0)
			push_back_ifUnique(_Gamma, px/c1 - (d5+d6)*(oz/s5));
	}
	if(s1 != 0.0) {
		push_back_ifUnique(_Gamma, py/s1 - (d5+d6)*(ay/s1));
		if(c5 != 0.0) 
			push_back_ifUnique(_Gamma, py/s1 + (d5+d6)*(nz/c5));
		if(c1 != 0.0)
			push_back_ifUnique(_Gamma, py/s1 - (d5+d6)*(ax/c1));
		if(s5 != 0.0)
			push_back_ifUnique(_Gamma, py/s1 - (d5+d6)*(oz/s5));
	}

	double term = d0 + d1 - pz;
	_Omega.push_back(term + (d5+d6)*az);
	if(c1 != 0.0) {
		if(c5 != 0.0)
			push_back_ifUnique(_Omega, term+(d5+d6)*( (nx+s1*s5) / (c1*c5) ) );
		if(s5 != 0.0)
			push_back_ifUnique(_Omega, term+(d5+d6)*( (-ox-s1*c5) / (c1*s5) ) );
	}
	if(s1 != 0.0) {
		if(c5 != 0.0)
			push_back_ifUnique(_Omega, term+(d5+d6)*( (ny-c1*s5) / (s1*c5) ) );
		if(s5 != 0.0)
			push_back_ifUnique(_Omega, term+(d5+d6)*( (-oy+c1*c5) / (s1*s5) ) );
	}
	
	for(unsigned int r = 0; r < _Gamma.size(); r++) {
		for(unsigned int s = 0; s < _Omega.size(); s++) {
			double j3_cos = (_Gamma[r]*_Gamma[r]+_Omega[s]*_Omega[s]-(a2*a2)-(a3*a3)) / (2.0*a2*a3);
			double j3_sin = sqrt(1 - j3_cos*j3_cos);
			double tempSolution;
			
			tempSolution = atan2(j3_sin, j3_cos);
			if(validateJoint(2, tempSolution, j3))
				solveJoint2(joint1, joint5, j3.back(), _Gamma, _Omega);

			tempSolution = atan2(-j3_sin, j3_cos);
			if(validateJoint(2, tempSolution, j3))
				solveJoint2(joint1, joint5, j3.back(), _Gamma, _Omega);
				
			tempSolution = atan2(-j3_sin, -j3_cos);
			if(validateJoint(2, tempSolution, j3))
				solveJoint2(joint1, joint5, j3.back(), _Gamma, _Omega);
				
			tempSolution = atan2(j3_sin, -j3_cos);
			if(validateJoint(2, tempSolution, j3))
				solveJoint2(joint1, joint5, j3.back(), _Gamma, _Omega);
		}
	}
	
	if(j3.size() == 0)
		ROS_DEBUG("Unable to find solution for joint 3");
}

/*
* JOINT 2
*/
void YoubotArmAnalyticalIK::solveJoint2(double joint1, double joint5, double joint3, std::vector<double> &Gamma, std::vector<double> &Omega) {
	double c1 = cos(joint1);
	double s1 = sin(joint1);
	double c5 = cos(joint5);
	double s5 = sin(joint5);
	double c3 = cos(joint3);
	double s3 = sin(joint3);
	std::vector<double> j2;
	double tempSolution;
	
	ROS_DEBUG_STREAM("Gamma.size = " << Gamma.size() << " || Omega.size = " << Omega.size());
	
	for(unsigned int s=0; s < Omega.size(); s++) {
		for(unsigned int r=0; r < Gamma.size(); r++) {
			tempSolution = atan2( ((a2+a3*c3)*Omega[s] - (a3*s3)*Gamma[r]) , ((a2+a3*c3)*Gamma[r] + (a3*s3)*Omega[s]));
			if(validateJoint(1, tempSolution, j2))
				solveJoint4(joint1, joint5, joint3, j2.back());

			tempSolution = acos( ( (a2+a3*c3)*Gamma[r]+a3*s3*Omega[s]) / (Gamma[r]*Gamma[r] + Omega[s]*Omega[s]));
			if(validateJoint(1, tempSolution, j2))
				solveJoint4(joint1, joint5, joint3, j2.back());
				
			tempSolution = asin( ( (a2+a3*c3)*Omega[s]-a3*s3*Gamma[r]) / (Gamma[r]*Gamma[r] + Omega[s]*Omega[s]));
			if(validateJoint(1, tempSolution, j2))
				solveJoint4(joint1, joint5, joint3, j2.back());
		}
	}
	if(j2.size() == 0)
		ROS_DEBUG("Unable to find solution for joint 2");
}



/*
* JOINT 4
*/
void YoubotArmAnalyticalIK::solveJoint4(double joint1, double joint5, double joint3, double joint2) {
	double s1 = sin(joint1);
	double c1 = cos(joint1);
	double s2 = sin(joint2);
	double c2 = cos(joint2);
	double c23 = cos(joint2+joint3);
	double s23 = sin(joint2+joint3);
	double s5 = sin(joint5);
	double c5 = cos(joint5);
	std::vector<double> _c234;
	std::vector<double> _s234;
	std::vector<double> j4;
	
	if(c1 != 0.0) {
		if(c5 != 0.0) 
			push_back_ifUnique( _c234,(nx+s1*s5)/(c1*c5));
		if(s5 != 0.0)
			push_back_ifUnique( _c234,(-ox-s1*c5)/(c1*s5));
	}
	if(s1 != 0.0) {
		if(c5 != 0.0)
			push_back_ifUnique( _c234,(ny-c1*s5)/(s1*c5));
		if(s5 != 0.0)
			push_back_ifUnique( _c234,(-oy+c1*c5)/(s1*s5));
	}
	push_back_ifUnique( _c234,(1.0/(d5+d6))*(pz-(d0+d1)+a2*s2+a3*s23));
	push_back_ifUnique( _c234,az);

	if(c1 != 0.0) {
		push_back_ifUnique( _s234, ax/c1);
		push_back_ifUnique( _s234, (1.0/(d5+d6))*((px/c1) - a2*c2-a3*c23));
	}
	if(s1 != 0.0) {
		push_back_ifUnique( _s234, ay/s1);
		push_back_ifUnique( _s234, (1.0/(d5+d6))*((px/s1) - a2*c2-a3*c23) );
	}
	if(c5 != 0.0)
		push_back_ifUnique( _s234, -nz/c5);
	if(s5 != 0.0)
		push_back_ifUnique( _s234, oz/s5);

	for(int r = 0; r < _c234.size(); r++) {
		for(int s = 0; s < _s234.size(); s++) {
			double tempSolution = atan2( (c23*_s234[s]-s23*_c234[r]),(s23*_s234[s]+c23*_c234[r]) );
			if(validateJoint(3, tempSolution, j4))
				addNewSolution(joint1, joint2, joint3, j4.back(), joint5);	
			tempSolution = acos(s23*_s234[s]+c23*_c234[r]);
			if(validateJoint(3, tempSolution, j4))
				addNewSolution(joint1, joint2, joint3, j4.back(), joint5);
			tempSolution = asin(c23*_s234[s]-s23*_c234[r]);
			if(validateJoint(3, tempSolution, j4))
				addNewSolution(joint1, joint2, joint3, j4.back(), joint5);
		}
	}

	if(j4.size() == 0) 
		ROS_DEBUG("Unable to find solution for joint 4");
}

void YoubotArmAnalyticalIK::addNewSolution(double j1, double j2, double j3, double j4, double j5) {
	KDL::JntArray solution(5);
	solution(0) = j1;
	solution(1) = j2;
	solution(2) = j3;
	solution(3) = j4;
	solution(4) = j5;
	solutions.push_back(solution);
}

bool YoubotArmAnalyticalIK::validateJoint(int j_index, double j_element, std::vector<double> &j_vector) {
	if( isJointValid(j_element, j_index) && push_back_ifUnique(j_vector, j_element) )
		return true;
	return false;
}

bool YoubotArmAnalyticalIK::push_back_ifUnique(
		std::vector<double> &vect, double newElement) {
	unsigned int size = vect.size();
	double error = 1e-3;
	if(size < 1) {
		vect.push_back(newElement);
		return true;
	}
	for(unsigned int i = 0; i < size; i++) {
		if(std::abs(vect[i] - newElement) < error) {
			return false;
		}
	}
	vect.push_back(newElement);
	return true;
}


/*
* Checks whether a Joint has a valid value.
*/
bool YoubotArmAnalyticalIK::isJointValid(double jointValue, int jointNum) const {
	bool valid = true;
	
	if((jointValue <= _min_angles[jointNum]) || (jointValue >= _max_angles[jointNum])) {
      valid = false;
	}
	if(jointValue != jointValue) {
		//ROS_INFO_ONCE("We have a NaN!!!");
		valid = false;
	}
	return valid;
}

bool YoubotArmAnalyticalIK::isSolutionValid(const KDL::JntArray &solution) const {
  bool valid = true;

  if (solution.rows() != 5) return false;

  for (unsigned int i = 0; i < solution.rows(); i++) {
    if ((solution(i) < _min_angles[i]) || (solution(i) > _max_angles[i])) {
      valid = false;
    }
  }

  return valid;
}


bool YoubotArmAnalyticalIK::validateSolutionWithFK(double joint1, double joint2, double joint3, double joint4, double joint5) {
	double error = 0.001; //TODO add the error from moveit
	double nx_fk, ox_fk, ax_fk, px_fk;
	double ny_fk, oy_fk, ay_fk, py_fk;
	double nz_fk, oz_fk, az_fk, pz_fk;
	double c1 = cos(joint1), s1 = sin(joint1);
	double c2 = cos(joint2), s2 = sin(joint2);
	double c23 = cos(joint2+joint3), s23 = sin(joint2+joint3);
	double c234 = cos(joint2+joint3+joint4);
	double s234 = sin(joint2+joint3+joint4);
	double c5 = cos(joint5), s5 = sin(joint5);

	ROS_DEBUG_STREAM("CHECKING WITH FK");
	// Forward kinematics:
	nx_fk = c234*c1*c5 - s1*s5;
	ny_fk = c234*s1*c5 + c1*s5;
	nz_fk = -s234*c5;
	ox_fk = -c234*c1*s5 - s1*c5;
	oy_fk = -c234*s1*s5 + c1*c5;
	oz_fk = s234*s5;
	ax_fk = s234*c1;
	az_fk = c234;
	px_fk = c1*(a2*c2 + a3*c23 + (d5+d6)*s234);
	py_fk = s1*(a2*c2 + a3*c23 + (d5+d6)*s234);
	pz_fk = d0 + d1 - a2*s2 - a3*s23 + (d5+d6)*c234;
	
	// Comparison
	if(std::abs(nx - nx_fk) > error)
		return false;
	if(std::abs(ny - ny_fk) > error)
		return false;
	if(std::abs(nz - nz_fk) > error)
		return false;
	if(std::abs(ox - ox_fk) > error)
		return false;
	if(std::abs(oy - oy_fk) > error)
		return false;
	if(std::abs(oz - oz_fk) > error)
		return false;
	if(std::abs(ax - ax_fk) > error)
		return false;
	if(std::abs(ay - ay_fk) > error)
		return false;
	if(std::abs(az - az_fk) > error)
		return false; 
	if(std::abs(px - px_fk) > error) {
		ROS_DEBUG_STREAM("PX is faulty, error = " << std::abs(px - px_fk));
		return false;
	}
	if(std::abs(py - py_fk) > error) {
		ROS_DEBUG_STREAM("PY is faulty, error = " << std::abs(py - py_fk));
		return false;
	}
	if(std::abs(pz - pz_fk) > error) {
		ROS_DEBUG_STREAM("PZ is faulty, error = " << std::abs(pz - pz_fk));
		return false;
	}
	
	return true;
}

} /* namespace youbot_kinematics */
